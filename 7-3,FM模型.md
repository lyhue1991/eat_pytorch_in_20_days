# 7-3ï¼ŒFMæ¨¡å‹


FMç®—æ³•å…¨ç§°ä¸ºå› å­åˆ†è§£æœº (FactorizationMachine)ã€‚

å®ƒæ˜¯å¹¿å‘Šå’Œæ¨èé¢†åŸŸéå¸¸è‘—åçš„ç®—æ³•ï¼Œåœ¨çº¿æ€§å›å½’æ¨¡å‹ä¸Šè€ƒè™‘äº†ç‰¹å¾çš„äºŒé˜¶äº¤äº’ã€‚

é€‚åˆæ•æ‰å¤§è§„æ¨¡ç¨€ç–ç‰¹å¾(ç±»åˆ«ç‰¹å¾)å½“ä¸­çš„ç‰¹å¾äº¤äº’ã€‚

FMåŠå…¶è¡ç”Ÿçš„ä¸€äº›è¾ƒæœ‰åçš„ç®—æ³•çš„ç®€è¦ä»‹ç»å¦‚ä¸‹ï¼š

* FM(FactorizationMachine)ï¼šåœ¨LRåŸºç¡€ä¸Šç”¨éšå‘é‡ç‚¹ç§¯å®ç°è‡ªåŠ¨åŒ–ç‰¹å¾äºŒé˜¶äº¤å‰ï¼Œä¸”äº¤äº’é¡¹çš„è®¡ç®—å¤æ‚åº¦æ˜¯O(n)ï¼Œæ•ˆæœæ˜¾è‘—å¥½äºLRï¼Œé€Ÿåº¦æå¿«æ¥è¿‘LRã€‚

* FFM(Field Aware FM): åœ¨FMçš„åŸºç¡€ä¸Šè€ƒè™‘å¯¹ä¸åŒçš„ç‰¹å¾åŸŸ(Fieldï¼Œå¯ä»¥ç†è§£æˆç‰¹å¾çš„åˆ†ç»„)ä½¿ç”¨ä¸åŒçš„éšå‘é‡ã€‚æ•ˆæœå¥½äºFMï¼Œä½†å‚æ•°é‡æ€¥å‰§å¢åŠ ï¼Œä¸”é¢„æµ‹æ€§èƒ½æ€¥å‰§ä¸‹é™ã€‚

* Bilinear-FFM: åŒçº¿æ€§FFMã€‚ä¸ºäº†å‡å°‘FFMçš„å‚æ•°é‡ï¼Œè®¾è®¡å…±äº«çŸ©é˜µæ¥ä»£æ›¿é’ˆå¯¹ä¸åŒFieldçš„å¤šä¸ªéšå‘é‡ã€‚æ•ˆæœæ¥è¿‘FFMï¼Œä½†å‚æ•°é‡å¤§å¤§å‡å°‘ï¼Œä¸FMç›¸å½“ã€‚äº¤äº’åæ·»åŠ LayerNormlizationæ—¶æ•ˆæœå’Œç•¥å¥½äºFFM.

* DeepFM: ä½¿ç”¨FMæ¨¡å‹ä»£æ›¿DeepWideä¸­çš„Wideéƒ¨åˆ†ï¼Œä¸”FMéƒ¨åˆ†çš„éšå‘é‡ä¸Deepéƒ¨åˆ†çš„Embeddingå‘é‡æ˜¯å…±äº«çš„ã€‚FMéƒ¨åˆ†å¯ä»¥æ•è·äºŒé˜¶æ˜¾å¼ç‰¹å¾äº¤å‰ï¼Œè€ŒDeepéƒ¨åˆ†èƒ½å¤Ÿæ•è·é«˜é˜¶éšå¼ç‰¹å¾ç»„åˆå’Œäº¤å‰ã€‚

* FiBiNET: ä½¿ç”¨SEæ³¨æ„åŠ›(Squeeze-and-Excitation)æœºåˆ¶æ¥æ•è·ç‰¹å¾é‡è¦æ€§ï¼Œå¹¶ä¸”ä½¿ç”¨Bilinear-FFMæ¥æ•è·äºŒé˜¶ç‰¹å¾äº¤äº’ã€‚

å‚è€ƒæ–‡ç« ï¼šå¼ ä¿Šæ—ã€ŠFFMåŠDeepFFMæ¨¡å‹åœ¨æ¨èç³»ç»Ÿçš„æ¢ç´¢ã€‹https://zhuanlan.zhihu.com/p/67795161

<br>

<font color="red">
 
å…¬ä¼—å· **ç®—æ³•ç¾é£Ÿå±‹** å›å¤å…³é”®è¯ï¼š**pytorch**ï¼Œ è·å–æœ¬é¡¹ç›®æºç å’Œæ‰€ç”¨æ•°æ®é›†ç™¾åº¦äº‘ç›˜ä¸‹è½½é“¾æ¥ã€‚
    
</font> 



```python
import torch 
print("torch.__version__="+torch.__version__) 
```

```
torch.__version__=1.10.0
```

```python

```

##  ä¸€ï¼ŒFMåŸç†è§£æ

FMæ¨¡å‹çš„è¡¨è¾¾å½¢å¼å¦‚ä¸‹ï¼š

$$y_{FM} = x_0 + \sum_{i=1}^n \omega_i x_i + \sum_{i=1}^{n-1}\sum_{j=i+1}^{n} <\vec{v_i},\vec{v_j}> x_i x_j$$

å…¶ä¸­ å‰ä¸¤é¡¹ä¸ çº¿æ€§å›å½’ä¸€è‡´ã€‚

ç¬¬ä¸‰é¡¹ä¸ºç‰¹å¾äº¤äº’é¡¹ã€‚ç”¨éšå‘é‡çš„ç‚¹ç§¯æ¥è®¡ç®—äº¤äº’é¡¹çš„ç³»æ•°ã€‚è¿™æ ·åšæ¯”ç›´æ¥è®¾å®šä¸€ä¸ª$n\times n$çš„äº¤äº’å‚æ•°çŸ©é˜µ$W$çš„å¥½å¤„æ˜¯å‡å°‘äº†å‚æ•°æ•°é‡ï¼Œå‚æ•°æ•°é‡ä» $n^2$å‡å°‘ä¸º $n\times k$ï¼Œå…¶ä¸­kä¸ºéšå‘é‡$v_i$çš„é•¿åº¦ã€‚

ä»æ•°å­¦ä¸Šï¼ŒFMç®—æ³•ç”¨ä¸€ç»„å‘é‡çš„ä¸¤ä¸¤å†…ç§¯ä»£æ›¿äº†äº¤äº’å‚æ•°çŸ©é˜µ$W$ï¼Œç­‰ä»·äºå°†å¯¹ç§°çŸ©é˜µWåˆ†è§£æˆå¦‚ä¸‹å½¢å¼$W=V^TV$ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆFMç®—æ³•è¢«å«åšå› å­åˆ†è§£æœºã€‚


éå¸¸æœ‰æ„æ€çš„æ˜¯ï¼Œäº¤äº’é¡¹çš„è®¡ç®—å¤æ‚åº¦ä¹Ÿå¯ä»¥ç”± $O(n^2)$ é™ä½ä¸º $O(nk)$ï¼Œè¿™æ ·FMå‰å‘æ¨æ–­çš„è®¡ç®—å¤æ‚åº¦è¿‘ä¼¼ä¸ºçº¿æ€§å¤æ‚åº¦ã€‚å¯¹äºç‰¹å¾æ•°é‡néå¸¸å¤§è€Œç¨€ç–çš„æ¨¡å‹ï¼Œè®¡ç®—èµ·æ¥æ¯«æ— å‹åŠ›ã€‚



äº¤äº’é¡¹çš„ç®€åŒ–è®¡ç®—ç±»ä¼¼äº $ab+ac+bc =\frac{1}{2} ((a+b+c)^2-(a^2+b^2+c^2))$


$$\sum_{i=1}^{n-1}\sum_{j=i+1}^{n} <\vec{v_i},\vec{v_j}> x_i x_j
= \frac{1}{2}(\sum_{i=1}^{n}\sum_{j=1}^{n} <\vec{v_i},\vec{v_j}> x_i x_j - \sum_{i=1}^{n} <\vec{v_i},\vec{v_i}> x_i x_i)$$
$$= \frac{1}{2}(\sum_{i=1}^{n}\sum_{j=1}^{n} \sum_{f=1}^{k} v_{if}v_{jf} x_i x_j - \sum_{i=1}^{n} \sum_{f=1}^{k} v_{if}v_{if} x_i x_i)$$

$$= \frac{1}{2}\sum_{f=1}^{k}(\sum_{i=1}^{n}\sum_{j=1}^{n}  v_{if}v_{jf} x_i x_j - \sum_{i=1}^{n}  v_{if}v_{if} x_i x_i)$$

$$= \frac{1}{2}\sum_{f=1}^{k}((\sum_{i=1}^{n}v_{if}x_i)^2  - \sum_{i=1}^{n}  (v_{if} x_i)^2)$$

å¯ä»¥çœ‹åˆ°äº¤äº’é¡¹çš„è®¡ç®—å¤æ‚åº¦å·²ç»å˜æˆ $O(nk)$ äº†

å› æ­¤ FMçš„æ¨¡å‹å½¢å¼ä¹Ÿå¯ä»¥æ”¹å†™æˆï¼š

$$y_{FM} = x_0 + \sum_{i=1}^n \omega_i x_i +\frac{1}{2}\sum_{f=1}^{k}((\sum_{i=1}^{n}v_{if}x_i)^2  - \sum_{i=1}^{n}  (v_{if} x_i)^2)$$


æ³¨æ„åˆ° 

$$\frac{\partial{y_{FM}}}{\partial{v_{if}}} = (\sum_{j=1}^{n}v_{jf}x_j) x_i - v_{if}x_i^2$$
$$= x_i((\sum_{j=1}^{n}v_{jf}x_j)  - v_{if}x_i)$$

å¯è§ï¼Œåªè¦è®­ç»ƒæ ·æœ¬ä¸­å­˜åœ¨ä¸ç­‰äº0çš„ $x_i$ ï¼Œå°±èƒ½å¤Ÿç»™éšå‘é‡$\vec{v_{i}}$è´¡çŒ®æ¢¯åº¦ï¼Œä»è€Œå­¦åˆ°æœ‰æ•ˆçš„$\vec{v_{i}}$è¡¨ç¤ºã€‚

åŒç†ï¼Œåªè¦è®­ç»ƒæ ·æœ¬ä¸­å­˜åœ¨ä¸ç­‰äº0çš„ $x_j$ ï¼Œå°±èƒ½å¤Ÿç»™éšå‘é‡$\vec{v_{j}}$è´¡çŒ®æ¢¯åº¦ï¼Œä»è€Œå­¦åˆ°æœ‰æ•ˆçš„$\vec{v_{j}}$è¡¨ç¤ºã€‚

ç„¶åï¼Œå°±å¯ä»¥è®¡ç®—å‡ºæœ‰æ„ä¹‰çš„äº¤äº’é¡¹çš„æƒé‡$<\vec{v_{i}},\vec{v_{j}}>$ã€‚

è¿™éå¸¸é‡è¦ï¼Œè¿™è¯´æ˜éé›¶çš„äº¤äº’é¡¹æƒé‡å¯ä»¥åœ¨è®­ç»ƒæ ·æœ¬ä¸­ä¸å­˜åœ¨ $x_i$å’Œ$x_j$åŒæ—¶ä¸ä¸º0çš„æ ·æœ¬çš„å‘ç”Ÿã€‚

è¿™æ˜¯FMé¢å¯¹ç¨€ç–ç‰¹å¾å…·æœ‰å¾ˆå¼ºæ³›åŒ–æ€§çš„åŸå› ã€‚

è€ƒè™‘ä¸€ä¸ªå…¸å‹çš„ç»™ç”¨æˆ·æ¨èå•†å“çš„æ¨èåœºæ™¯ä¸­ï¼Œç”¨æˆ·æ‰€åœ¨åŸå¸‚ç‰¹å¾å’Œå•†å“ç±»ç›®ç‰¹å¾çš„äº¤äº’ã€‚

è‘«èŠ¦å²›æ˜¯ä¸€ä¸ªå°åŸå¸‚ï¼Œæ¸”ç½‘æ˜¯ä¸€ç§å°ä¼—å•†å“ã€‚å®ƒä»¬éƒ½æ˜¯ç¨€ç–ç‰¹å¾ï¼Œç»å¤§éƒ¨åˆ†æ ·æœ¬åœ¨è¿™ä¸¤ä¸ªonehotä½ä¸Šçš„å–å€¼éƒ½æ˜¯0.

ç¨€ç–ä¹˜ä»¥ç¨€ç–æ›´åŠ ç¨€ç–ï¼Œæ‰€ä»¥åœ¨è®­ç»ƒæ ·æœ¬ä¸­å¯èƒ½æ ¹æœ¬ä¸å­˜åœ¨è‘«èŠ¦å²›åŸå¸‚çš„ç”¨æˆ·è´­ä¹°æ¸”ç½‘è¿™æ ·çš„æ ·æœ¬ã€‚

ä½†æ˜¯åªè¦è®­ç»ƒæ ·æœ¬ä¸­å­˜åœ¨ç€è‘«èŠ¦å²›çš„ç”¨æˆ·è´­ä¹°å…¶å®ƒå•†å“è¿™æ ·çš„æ ·æœ¬ï¼Œä¹Ÿå­˜åœ¨å…¶ä»–åŸå¸‚ç”¨æˆ·è´­ä¹°æ¸”ç½‘è¿™æ ·çš„æ ·æœ¬ï¼ŒFMæ¨¡å‹å°±å¯ä»¥ç»™è‘«èŠ¦å²›å¸‚çš„ç”¨æˆ·è´­ä¹°æ¸”ç½‘çš„å¯èƒ½æ€§ä½œå‡ºä¸€ä¸ªä¼°è®¡ï¼Œè¿™ä¸ªå€¼å¯èƒ½ä¸å°ï¼Œæœ€åç”šè‡³ä¼šç»™è‘«èŠ¦å²›çš„ç”¨æˆ·æ¨èæ¸”ç½‘ã€‚

è¿™å°±æ˜¯FMé¢å¯¹ç¨€ç–ç‰¹å¾å…·æœ‰å¾ˆå¼ºæ³›åŒ–æ€§çš„ä¸€ä¸ªä¾‹å­ã€‚








```python

```

## äºŒï¼ŒPytorchä»£ç å®ç°


ä¸‹é¢æ˜¯FMæ¨¡å‹çš„ä¸€ä¸ªå®Œæ•´pytorchå®ç°ã€‚


$$\sum_{i=1}^{n-1}\sum_{j=i+1}^{n} <\vec{v_i},\vec{v_j}> x_i x_j = \sum_{i=1}^{n-1}\sum_{j=i+1}^{n} <x_i\vec{v_i},x_j\vec{v_j}> $$

æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬ä»£ç ä¸­çš„embeddingå‘é‡æˆ–è€…çº¿æ€§å±‚ä½œç”¨ç»“æœå®é™…ä¸Šæ˜¯ $x_i\vec{v_i}$ çš„ç»“æœã€‚è¿™æ˜¯è®¸å¤šè¯»è€…åŒ…æ‹¬æˆ‘åœ¨å­¦ä¹ FMæ—¶å€™æ„Ÿåˆ°å›°æƒ‘çš„ä¸€ä¸ªåœ°æ–¹ã€‚

å¯¹äº ç¦»æ•£ç‰¹å¾ï¼Œonehotç¼–ç åå…¶ $x_i $ æ€»æ˜¯ç­‰äº1æˆ–è€…0ï¼Œ$x_i$ä¸ä¸º0çš„é‚£äº›é¡¹æ‰ä¼šä¿ç•™åˆ°ç»“æœä¸­ï¼Œæ­¤æ—¶$x_i$æ€»æ˜¯ç­‰äº1ï¼Œå› æ­¤$x_i\vec{v_i}$å°±ç­‰äºå…¶embeddingå‘é‡ã€‚å¯¹äºè¿ç»­ç‰¹å¾ï¼Œé€šè¿‡ä¸€ä¸ªä¸å¸¦åç½®çš„Linearå±‚ä½œç”¨ï¼Œè·å–åˆ°çš„å®é™…ä¸Šå°±æ˜¯ $x_i\vec{v_i}$ï¼ŒåŒ…å«äº†$x_i$å› å­ã€‚


```python
import torch 
from torch import nn
from torch import nn,Tensor 
import torch.nn.functional as F 

class NumEmbedding(nn.Module):
    """
    è¿ç»­ç‰¹å¾ç”¨linearå±‚ç¼–ç 
    è¾“å…¥shape: [batch_size,features_num(n), d_in], # d_in é€šå¸¸æ˜¯1
    è¾“å‡ºshape: [batch_size,features_num(n), d_out]
    """
    
    def __init__(self, n: int, d_in: int, d_out: int, bias: bool = False) -> None:
        super().__init__()
        self.weight = nn.Parameter(Tensor(n, d_in, d_out))
        self.bias = nn.Parameter(Tensor(n, d_out)) if bias else None
        with torch.no_grad():
            for i in range(n):
                layer = nn.Linear(d_in, d_out)
                self.weight[i] = layer.weight.T
                if self.bias is not None:
                    self.bias[i] = layer.bias

    def forward(self, x_num):
        # x_num: batch_size, features_num, d_in
        assert x_num.ndim == 3
        #x = x_num[..., None] * self.weight[None]
        #x = x.sum(-2)
        x = torch.einsum("bfi,fij->bfj",x_num,self.weight)
        if self.bias is not None:
            x = x + self.bias[None]
        return x
    
class CatEmbedding(nn.Module):
    """
    ç¦»æ•£ç‰¹å¾ç”¨Embeddingå±‚ç¼–ç 
    è¾“å…¥shape: [batch_size,features_num], 
    è¾“å‡ºshape: [batch_size,features_num, d_embed]
    """
    def __init__(self, categories, d_embed):
        super().__init__()
        self.embedding = nn.Embedding(sum(categories), d_embed)
        self.offsets = nn.Parameter(
                torch.tensor([0] + categories[:-1]).cumsum(0),requires_grad=False)
        
        torch.nn.init.xavier_uniform_(self.embedding.weight.data)

    def forward(self, x_cat):
        """
        :param x_cat: Long tensor of size ``(batch_size, features_num)``
        """
        x = x_cat + self.offsets[None]
        return self.embedding(x) 
    
class CatLinear(nn.Module):
    """
    ç¦»æ•£ç‰¹å¾ç”¨Embeddingå®ç°çº¿æ€§å±‚ï¼ˆç­‰ä»·äºå…ˆF.onehotå†nn.Linear()ï¼‰
    è¾“å…¥shape: [batch_size,features_num], 
    è¾“å‡ºshape: [batch_size,d_out]
    """
    def __init__(self, categories, d_out=1):
        super().__init__()
        self.fc = nn.Embedding(sum(categories), d_out)
        self.bias = nn.Parameter(torch.zeros((d_out,)))
        self.offsets = nn.Parameter(
                torch.tensor([0] + categories[:-1]).cumsum(0),requires_grad=False)

    def forward(self, x_cat):
        """
        :param x: Long tensor of size ``(batch_size, features_num)``
        """
        x = x_cat + self.offsets[None]
        return torch.sum(self.fc(x), dim=1) + self.bias 
    
    
class FMLayer(nn.Module):
    """
    FMäº¤äº’é¡¹
    """

    def __init__(self, reduce_sum=True):
        super().__init__()
        self.reduce_sum = reduce_sum

    def forward(self, x): #æ³¨æ„ï¼šè¿™é‡Œçš„xæ˜¯å…¬å¼ä¸­çš„ <v_i> * xi
        """
        :param x: Float tensor of size ``(batch_size, num_features, k)``
        """
        square_of_sum = torch.sum(x, dim=1) ** 2
        sum_of_square = torch.sum(x ** 2, dim=1)
        ix = square_of_sum - sum_of_square
        if self.reduce_sum:
            ix = torch.sum(ix, dim=1, keepdim=True)
        return 0.5 * ix
    
class FM(nn.Module):
    """
    å®Œæ•´FMæ¨¡å‹ã€‚
    """

    def __init__(self, d_numerical, categories=None, d_embed=4,
                 n_classes = 1):
        super().__init__()
        if d_numerical is None:
            d_numerical = 0
        if categories is None:
            categories = []
        self.categories = categories
        self.n_classes = n_classes
        
        self.num_linear = nn.Linear(d_numerical,n_classes) if d_numerical else None
        self.cat_linear = CatLinear(categories,n_classes) if categories else None
        
        self.num_embedding = NumEmbedding(d_numerical,1,d_embed) if d_numerical else None
        self.cat_embedding = CatEmbedding(categories, d_embed) if categories else None
        
        if n_classes==1:
            self.fm = FMLayer(reduce_sum=True)
            self.fm_linear = None
        else:
            assert n_classes>=2
            self.fm = FMLayer(reduce_sum=False)
            self.fm_linear = nn.Linear(d_embed,n_classes)

    def forward(self, x):
        
        """
        x_num: numerical features
        x_cat: category features
        """
        x_num,x_cat = x
        
        #linearéƒ¨åˆ†
        x = 0.0
        if self.num_linear:
            x = x + self.num_linear(x_num) 
        if self.cat_linear:
            x = x + self.cat_linear(x_cat)
        
        #äº¤å‰é¡¹éƒ¨åˆ†
        x_embedding = []
        if self.num_embedding:
            x_embedding.append(self.num_embedding(x_num[...,None]))
        if self.cat_embedding:
            x_embedding.append(self.cat_embedding(x_cat))
        x_embedding = torch.cat(x_embedding,dim=1)
        
        if self.n_classes==1:
            x = x + self.fm(x_embedding)
            x = x.squeeze(-1)
        else: 
            x = x + self.fm_linear(self.fm(x_embedding)) 
        return x
    
    
```

```python
##æµ‹è¯• NumEmbedding

num_embedding = NumEmbedding(2,1,4)
x_num = torch.randn(2,2)
x_out = (num_embedding(x_num.unsqueeze(-1)))
print(x_out.shape)        
```

```python
##æµ‹è¯• CatEmbedding

cat_embedding = CatEmbedding(categories = [3,2,2],d_embed=4) 
x_cat = torch.randint(0,2,(2,3))
x_out = cat_embedding(x_cat)
print(x_cat.shape)
print(x_out.shape)

```

```python
##æµ‹è¯• CatLinear

cat_linear = CatLinear(categories = [3,2,2],d_out=1) 
x_cat = torch.randint(0,2,(2,3))
x_out = cat_linear(x_cat)
print(x_cat.shape)
print(x_out.shape)

```

```python
##æµ‹è¯• FMLayer

fm_layer = FMLayer(reduce_sum=False)

x = torch.randn(2,3,4)
x_out = fm_layer(x)
print(x_out.shape)

```

```python
##æµ‹è¯• FM

fm = FM(d_numerical = 3, categories = [4,3,2],
        d_embed = 4,n_classes = 2)
self = fm 
x_num = torch.randn(2,3)
x_cat = torch.randint(0,2,(2,3))
fm((x_num,x_cat))

```


## ä¸‰ï¼ŒCretioæ•°æ®é›†å®Œæ•´èŒƒä¾‹


Cretioæ•°æ®é›†æ˜¯ä¸€ä¸ªç»å…¸çš„å¹¿å‘Šç‚¹å‡»ç‡CTRé¢„æµ‹æ•°æ®é›†ã€‚

è¿™ä¸ªæ•°æ®é›†çš„ç›®æ ‡æ˜¯é€šè¿‡ç”¨æˆ·ç‰¹å¾å’Œå¹¿å‘Šç‰¹å¾æ¥é¢„æµ‹æŸæ¡å¹¿å‘Šæ˜¯å¦ä¼šä¸ºç”¨æˆ·ç‚¹å‡»ã€‚

æ•°æ®é›†æœ‰13ç»´æ•°å€¼ç‰¹å¾(I1è‡³I13)å’Œ26ç»´ç±»åˆ«ç‰¹å¾(C14è‡³C39), å…±39ç»´ç‰¹å¾, ç‰¹å¾ä¸­åŒ…å«ç€è®¸å¤šç¼ºå¤±å€¼ã€‚

è®­ç»ƒé›†4000ä¸‡ä¸ªæ ·æœ¬ï¼Œæµ‹è¯•é›†600ä¸‡ä¸ªæ ·æœ¬ã€‚æ•°æ®é›†å¤§å°è¶…è¿‡100G.

æ­¤å¤„ä½¿ç”¨çš„æ˜¯é‡‡æ ·100ä¸‡ä¸ªæ ·æœ¬åçš„cretio_smallæ•°æ®é›†ã€‚


```python
#!pip install torchkeras
```

```python
import numpy as np 
import pandas as pd 
import datetime 

from sklearn.model_selection import train_test_split 

import torch 
from torch import nn 
from torch.utils.data import Dataset,DataLoader  
import torch.nn.functional as F 
import torchkeras 

def printlog(info):
    nowtime = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print("\n"+"=========="*8 + "%s"%nowtime)
    print(info+'...\n\n')

```

```python

```

### 1ï¼Œå‡†å¤‡æ•°æ®

```python
from sklearn.preprocessing import LabelEncoder,QuantileTransformer
from sklearn.pipeline import Pipeline 
from sklearn.impute import SimpleImputer 

dfdata = pd.read_csv("./eat_pytorch_datasets/criteo_small.zip",sep="\t",header=None)
dfdata.columns = ["label"] + ["I"+str(x) for x in range(1,14)] + [
    "C"+str(x) for x in range(14,40)]

cat_cols = [x for x in dfdata.columns if x.startswith('C')]
num_cols = [x for x in dfdata.columns if x.startswith('I')]
num_pipe = Pipeline(steps = [('impute',SimpleImputer()),('quantile',QuantileTransformer())])

for col in cat_cols:
    dfdata[col]  = LabelEncoder().fit_transform(dfdata[col])

dfdata[num_cols] = num_pipe.fit_transform(dfdata[num_cols])

categories = [dfdata[col].max()+1 for col in cat_cols]


```

```python
import torch 
from torch.utils.data import Dataset,DataLoader 

#DataFrameè½¬æ¢æˆtorchæ•°æ®é›†Dataset, ç‰¹å¾åˆ†å‰²æˆX_num,X_catæ–¹å¼
class DfDataset(Dataset):
    def __init__(self,df,
                 label_col,
                 num_features,
                 cat_features,
                 categories,
                 is_training=True):
        
        self.X_num = torch.tensor(df[num_features].values).float() if num_features else None
        self.X_cat = torch.tensor(df[cat_features].values).long() if cat_features else None
        self.Y = torch.tensor(df[label_col].values).float() 
        self.categories = categories
        self.is_training = is_training
    
    def __len__(self):
        return len(self.Y)
    
    def __getitem__(self,index):
        if self.is_training:
            return ((self.X_num[index],self.X_cat[index]),self.Y[index])
        else:
            return (self.X_num[index],self.X_cat[index])
    
    def get_categories(self):
        return self.categories

```

```python
dftrain_val,dftest = train_test_split(dfdata,test_size=0.2)
dftrain,dfval = train_test_split(dftrain_val,test_size=0.2)

ds_train = DfDataset(dftrain,label_col = "label",num_features = num_cols,cat_features = cat_cols,
                    categories = categories, is_training=True)

ds_val = DfDataset(dfval,label_col = "label",num_features = num_cols,cat_features = cat_cols,
                    categories = categories, is_training=True)

ds_test = DfDataset(dftest,label_col = "label",num_features = num_cols,cat_features = cat_cols,
                    categories = categories, is_training=True)


```

```python
dl_train = DataLoader(ds_train,batch_size = 2048,shuffle=True)
dl_val = DataLoader(ds_val,batch_size = 2048,shuffle=False)
dl_test = DataLoader(ds_test,batch_size = 2048,shuffle=False)

for features,labels in dl_train:
    break 
    
```


### 2ï¼Œå®šä¹‰æ¨¡å‹

```python
def create_net():
    net = FM(
        d_numerical= ds_train.X_num.shape[1],
        categories= ds_train.get_categories(),
        d_embed = 8, 
        n_classes = 1
    )
    return net 

from torchkeras import summary

net = create_net()
summary(net,input_data=features);


```

```
--------------------------------------------------------------------------
Layer (type)                            Output Shape              Param #
==========================================================================
Linear-1                                     [-1, 1]                   14
Embedding-2                              [-1, 26, 1]            1,296,709
NumEmbedding-3                           [-1, 13, 8]                  104
Embedding-4                              [-1, 26, 8]           10,373,672
FMLayer-5                                    [-1, 1]                    0
==========================================================================
Total params: 11,670,499
Trainable params: 11,670,499
Non-trainable params: 0
--------------------------------------------------------------------------
Input size (MB): 0.000084
Forward/backward pass size (MB): 0.002594
Params size (MB): 44.519421
Estimated Total Size (MB): 44.522099
--------------------------------------------------------------------------
```

```python

```

### 3ï¼Œè®­ç»ƒæ¨¡å‹

```python

```

```python
import os,sys,time
import numpy as np
import pandas as pd
import datetime 
from tqdm import tqdm 

import torch
from torch import nn 
from accelerate import Accelerator
from copy import deepcopy


def printlog(info):
    nowtime = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print("\n"+"=========="*8 + "%s"%nowtime)
    print(str(info)+"\n")
    
class StepRunner:
    def __init__(self, net, loss_fn,stage = "train", metrics_dict = None, 
                 optimizer = None, lr_scheduler = None,
                 accelerator = None
                 ):
        self.net,self.loss_fn,self.metrics_dict,self.stage = net,loss_fn,metrics_dict,stage
        self.optimizer,self.lr_scheduler = optimizer,lr_scheduler
        self.accelerator = accelerator
    
    def __call__(self, features, labels):
        #loss
        preds = self.net(features)
        loss = self.loss_fn(preds,labels)

        #backward()
        if self.optimizer is not None and self.stage=="train":
            if self.accelerator is  None:
                loss.backward()
            else:
                self.accelerator.backward(loss)
            self.optimizer.step()
            if self.lr_scheduler is not None:
                self.lr_scheduler.step()
            self.optimizer.zero_grad()
            
        #metrics
        step_metrics = {self.stage+"_"+name:metric_fn(preds, labels).item() 
                        for name,metric_fn in self.metrics_dict.items()}
        return loss.item(),step_metrics
    
    
class EpochRunner:
    def __init__(self,steprunner):
        self.steprunner = steprunner
        self.stage = steprunner.stage
        self.steprunner.net.train() if self.stage=="train" else self.steprunner.net.eval()
        
    def __call__(self,dataloader):
        total_loss,step = 0,0
        loop = tqdm(enumerate(dataloader), total =len(dataloader))
        for i, batch in loop:
            features,labels = batch
            if self.stage=="train":
                loss, step_metrics = self.steprunner(features,labels)
            else:
                with torch.no_grad():
                    loss, step_metrics = self.steprunner(features,labels)
                    
            step_log = dict({self.stage+"_loss":loss},**step_metrics)

            total_loss += loss
            step+=1
            if i!=len(dataloader)-1:
                loop.set_postfix(**step_log)
            else:
                epoch_loss = total_loss/step
                epoch_metrics = {self.stage+"_"+name:metric_fn.compute().item() 
                                 for name,metric_fn in self.steprunner.metrics_dict.items()}
                epoch_log = dict({self.stage+"_loss":epoch_loss},**epoch_metrics)
                loop.set_postfix(**epoch_log)

                for name,metric_fn in self.steprunner.metrics_dict.items():
                    metric_fn.reset()
        return epoch_log

class KerasModel(torch.nn.Module):
    def __init__(self,net,loss_fn,metrics_dict=None,optimizer=None,lr_scheduler = None):
        super().__init__()
        self.accelerator = Accelerator()
        self.history = {}
        
        self.net = net
        self.loss_fn = loss_fn
        self.metrics_dict = nn.ModuleDict(metrics_dict) 
        
        self.optimizer = optimizer if optimizer is not None else torch.optim.Adam(
            self.parameters(), lr=1e-2)
        self.lr_scheduler = lr_scheduler
        
        self.net,self.loss_fn,self.metrics_dict,self.optimizer = self.accelerator.prepare(
            self.net,self.loss_fn,self.metrics_dict,self.optimizer)

    def forward(self, x):
        if self.net:
            return self.net.forward(x)
        else:
            raise NotImplementedError


    def fit(self, train_data, val_data=None, epochs=10, ckpt_path='checkpoint.pt', 
            patience=5, monitor="val_loss", mode="min"):
        
        train_data = self.accelerator.prepare(train_data)
        val_data = self.accelerator.prepare(val_data) if val_data else []

        for epoch in range(1, epochs+1):
            printlog("Epoch {0} / {1}".format(epoch, epochs))
            
            # 1ï¼Œtrain -------------------------------------------------  
            train_step_runner = StepRunner(net = self.net,stage="train",
                    loss_fn = self.loss_fn,metrics_dict=deepcopy(self.metrics_dict),
                    optimizer = self.optimizer, lr_scheduler = self.lr_scheduler,
                    accelerator = self.accelerator)
            train_epoch_runner = EpochRunner(train_step_runner)
            train_metrics = train_epoch_runner(train_data)
            
            for name, metric in train_metrics.items():
                self.history[name] = self.history.get(name, []) + [metric]

            # 2ï¼Œvalidate -------------------------------------------------
            if val_data:
                val_step_runner = StepRunner(net = self.net,stage="val",
                    loss_fn = self.loss_fn,metrics_dict=deepcopy(self.metrics_dict),
                    accelerator = self.accelerator)
                val_epoch_runner = EpochRunner(val_step_runner)
                with torch.no_grad():
                    val_metrics = val_epoch_runner(val_data)
                val_metrics["epoch"] = epoch
                for name, metric in val_metrics.items():
                    self.history[name] = self.history.get(name, []) + [metric]
            
            # 3ï¼Œearly-stopping -------------------------------------------------
            arr_scores = self.history[monitor]
            best_score_idx = np.argmax(arr_scores) if mode=="max" else np.argmin(arr_scores)
            if best_score_idx==len(arr_scores)-1:
                torch.save(self.net.state_dict(),ckpt_path)
                print("<<<<<< reach best {0} : {1} >>>>>>".format(monitor,
                     arr_scores[best_score_idx]),file=sys.stderr)
            if len(arr_scores)-best_score_idx>patience:
                print("<<<<<< {} without improvement in {} epoch, early stopping >>>>>>".format(
                    monitor,patience),file=sys.stderr)
                break 
                
        self.net.load_state_dict(torch.load(ckpt_path))
            
        return pd.DataFrame(self.history)

    @torch.no_grad()
    def evaluate(self, val_data):
        val_data = self.accelerator.prepare(val_data)
        val_step_runner = StepRunner(net = self.net,stage="val",
                    loss_fn = self.loss_fn,metrics_dict=deepcopy(self.metrics_dict),
                    accelerator = self.accelerator)
        val_epoch_runner = EpochRunner(val_step_runner)
        val_metrics = val_epoch_runner(val_data)
        return val_metrics
        
       
    @torch.no_grad()
    def predict(self, dataloader):
        dataloader = self.accelerator.prepare(dataloader)
        result = torch.cat([self.forward(t[0]) for t in dataloader])
        return result.data
              
```

```python
from torchkeras.metrics import AUC

net = create_net()
loss_fn = nn.BCEWithLogitsLoss()

metrics_dict = {"auc":AUC()}
optimizer = torch.optim.Adam(net.parameters(), lr=0.005, weight_decay=0.001) 

model = KerasModel(net,
                   loss_fn = loss_fn,
                   metrics_dict= metrics_dict,
                   optimizer = optimizer
                  )         

```
```python
dfhistory = model.fit(train_data = dl_train,val_data = dl_val,
    epochs=20,
    ckpt_path='checkpoint.pt',
    patience=3,
    monitor='val_auc',
    mode='max')

```

```
================================================================================2022-08-11 19:39:44
Epoch 7 / 20

100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 313/313 [01:14<00:00,  4.18it/s, train_auc=0.768, train_loss=0.475]
100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 79/79 [00:03<00:00, 23.94it/s, val_auc=0.767, val_loss=0.477]
<<<<<< reach best val_auc : 0.7665905952453613 >>>>>>

================================================================================2022-08-11 19:41:02
Epoch 8 / 20

100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 313/313 [01:13<00:00,  4.23it/s, train_auc=0.768, train_loss=0.475]
100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 79/79 [00:03<00:00, 23.92it/s, val_auc=0.767, val_loss=0.477]
<<<<<< reach best val_auc : 0.7671190500259399 >>>>>>

================================================================================2022-08-11 19:42:20
Epoch 9 / 20

100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 313/313 [01:13<00:00,  4.25it/s, train_auc=0.769, train_loss=0.475]
100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 79/79 [00:03<00:00, 23.37it/s, val_auc=0.768, val_loss=0.476]
<<<<<< reach best val_auc : 0.768292248249054 >>>>>>
```

```python

```

```python

```

### 4ï¼Œè¯„ä¼°æ¨¡å‹

```python
%matplotlib inline
%config InlineBackend.figure_format = 'svg'

import matplotlib.pyplot as plt

def plot_metric(dfhistory, metric):
    train_metrics = dfhistory["train_"+metric]
    val_metrics = dfhistory['val_'+metric]
    epochs = range(1, len(train_metrics) + 1)
    plt.plot(epochs, train_metrics, 'bo--')
    plt.plot(epochs, val_metrics, 'ro-')
    plt.title('Training and validation '+ metric)
    plt.xlabel("Epochs")
    plt.ylabel(metric)
    plt.legend(["train_"+metric, 'val_'+metric])
    plt.show()
```

```python
plot_metric(dfhistory,"loss")
```

![](https://tva1.sinaimg.cn/large/e6c9d24egy1h532tdrdvsj20f40a6dg3.jpg)

```python
plot_metric(dfhistory,"auc")
```

![](https://tva1.sinaimg.cn/large/e6c9d24egy1h532uca1oij20f40a9aab.jpg)

```python
model.evaluate(dl_val)
```
```python

```

### 5ï¼Œä½¿ç”¨æ¨¡å‹

```python
from sklearn.metrics import roc_auc_score
model.eval()
preds = F.sigmoid(model.predict(dl_val))
labels = torch.cat([x[-1] for x in dl_val])

val_auc = roc_auc_score(labels.numpy(),preds.numpy())
print(val_auc)

```

```
0.768292257292055
```

```python

```

### 6ï¼Œä¿å­˜æ¨¡å‹


æ¨¡å‹æœ€ä½³æƒé‡å·²ç»ä¿å­˜åœ¨ model.fit(ckpt_path) ä¼ å…¥çš„å‚æ•°ä¸­äº†ã€‚

```python
net_clone = create_net()
net_clone.load_state_dict(torch.load("checkpoint.pt"))

```

```python
from sklearn.metrics import roc_auc_score
preds = torch.cat([F.sigmoid(net_clone(x[0])).data for x in dl_val]) 
labels = torch.cat([x[-1] for x in dl_val])

val_auc = roc_auc_score(labels.numpy(),preds.numpy())
print(val_auc)

```
```python

```

**å¦‚æœæœ¬ä¹¦å¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼Œæƒ³é¼“åŠ±ä¸€ä¸‹ä½œè€…ï¼Œè®°å¾—ç»™æœ¬é¡¹ç›®åŠ ä¸€é¢—æ˜Ÿæ˜Ÿstarâ­ï¸ï¼Œå¹¶åˆ†äº«ç»™ä½ çš„æœ‹å‹ä»¬å–”ğŸ˜Š!** 

å¦‚æœå¯¹æœ¬ä¹¦å†…å®¹ç†è§£ä¸Šæœ‰éœ€è¦è¿›ä¸€æ­¥å’Œä½œè€…äº¤æµçš„åœ°æ–¹ï¼Œæ¬¢è¿åœ¨å…¬ä¼—å·"ç®—æ³•ç¾é£Ÿå±‹"ä¸‹ç•™è¨€ã€‚ä½œè€…æ—¶é—´å’Œç²¾åŠ›æœ‰é™ï¼Œä¼šé…Œæƒ…äºˆä»¥å›å¤ã€‚

ä¹Ÿå¯ä»¥åœ¨å…¬ä¼—å·åå°å›å¤å…³é”®å­—ï¼š**åŠ ç¾¤**ï¼ŒåŠ å…¥è¯»è€…äº¤æµç¾¤å’Œå¤§å®¶è®¨è®ºã€‚

![ç®—æ³•ç¾é£Ÿå±‹logo.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h41m2zugguj20k00b9q46.jpg)
